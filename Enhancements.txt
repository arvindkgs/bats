NOTES:
-----------------------------------------------------------------------------------------------------------------------------------------
1. If dependent py_modules cannot be installed, the go for the custom JSON parser, but remember to implement following feature for (OHS):
   '..' - go to any depth and fetch the item/s named the following word
   Example: IfModule..mpm_worker_module..ServerLimit
   So in 'IfModule' go to its children/grandchildren/great-grandchildren/etc, till 'mpm_worker_module' is found.
2. Using the 'jsonpath_rw_ext' parser, causes it to return only elements that are found, unlike custom JSON parser that adds 'None'
   if particular object in array does not have property.
   This should not affect unless a property can have multiple values.
3. The dynamic block produces a list of values.
           * Each value from this list is used to evaluate a source and corresponding property value.
           * These values are then compared.
           * So based on the ordering of the dynamic block values, source and target properties are computed and compared.
           * So LIMITATION is extrapolation resulting in size(n) source properties, should also result in similar extrapolation
             on the target as well.
4. Now dynamic map can store dict type object and used to extrapolate('property', 'file', 'hostname', 'username',
   'password' elements in metadata) by attributes of each object. Note that if the attribute is list type then it will
   iterate over each of the list objects and get the corresponding values, so effectively flattening the list.

To-Do
-----------------------------------------------------------------------------------------------------------------------------------------
1. Create subcommands 'extract' for extracting the value given the property and file.
2. Convert tests to use the Resource objects instead of using the logs, so logs can have timestamp and run time.
3. Use REGEX for parsing format text.
4. Add STATIC type.
5. Currently each dynamic property is computed as list of values with file attribute of the dynamic component being a single file.
   * PROBLEM: However if the file attribute of the dynamic component is itself extrapolated to multiple files, then how to handle?
   * SOLUTION *
       * REFACTOR: Store each dynamic property as list of properties instead of list of values, so it can be a 2x2 where property is
            corresponding to a file.
       * CONSTRUCT: use the 'foreach' construct in the '${}' to make the list to be grouped on the property, versus the default which expands
            to a single list.
       * IMPACT:
            Consider following 'check':
            {
              "name": "Max capacity",
              "type": "COMPARE",
              "source": {
                "file": "metadatas/tests/jdbc/source.json",
                "type": "JSON",
                "property": "$.topology.wlsTunings[?(@.applicationName=${applicationName}&@.attributeName=MaxCapacity)].value"
              },
              "target": {
                "file": "metadatas/tests/${jdbcfileName}",
                "type": "XML",
                "property": "jdbc-data-source.jdbc-connection-pool-params.max-capacity"
              }
            }
            The 'target' has a 'file' attribute that is extrapolated to a list (above check is 'one-to-one' default) and each source item
            is compared to a target item.
            Now if : "file": "metadatas/tests/${jdbcfileName}" -> "file": "metadatas/tests/${foreach:jdbcfileName}"
            This means that each property of the dynamic property ${jdbcfileName}, is grouped by the dynamic property file,
            and the 'file' will give a list of properties grouped by the same dynamic property file.
            Now if cardinality of check is 'one-to-one', the all values inside all properties will be flattened to single list and source values
            are compared to all target values, but if it is 'one-to-many' then source values is compared to the value list of each property
            of the file attribute separately.
   OR
   * SOLUTION * This feels better, this can also potentially remove 'cardinality' construct *
   Introduce 'for' construct as,
   "checks": [{
        name: "JDBC Check"
        for: {
            each: "folder", //Add temporarily to dynamic map
            in: {
                "property": "ls /domain",
                "type": "SHELL"
            }
            do: {
                "dynamic": [{
                    "key": "config-file"
                    "property": "ls ${folder}/config.xml"
                    "type": "SHELL"
                }],
                "source": {}
                "target": { "file": "${config-file}"}
            }
        } //Remove the each variable from dynamic map
   }]


Done
---------------------------------------------------------------------------------------------------------------------------------------
1. Use POJO for storing property instead of tuple to avoid array of values when using extend.
2. Add name to dynamic property instead of referring to it using index.
3. Add SHELL type.
4. Speed up dynamic matching by storing global dynamic map,
    4.1 Previously compare fetches same dynamic values from JSON for each check.
    4.2 Now dynamic map can store objects in map in global scope and reuse for each check.
       "tests": [{
           "dynamic": [
            {
              "key": "clusterObj",
              "file": "metadatas/tests/jvm/source.json",
              "type": "JSON",
              "property": "$..wlsClusters[*]"
            }
          ],
          "checks": [
            {
              "name": "Xms Check",
              "type": "COMPARE",
              "source": {
                "property": "$..wlsClusters[?(@.clusterName=${clusterObj.clusterName})].Xms",
                "file": "metadatas/tests/jvm/source.json",
                "type": "JSON"
              },
              "target": {
                "property": "fusion.FADomain.${clusterObj.clusterName}.default.minmaxmemory.main",
                "file": "metadatas/tests/jvm/target.properties",
                "type": "PROPERTY",
                "format": "-Xms{}?"
              }
            }
          ]
       }]
5. Modified ShellHandler to execute ssh/scp commands on fly rather than invoking a .sh file, which requires the .sh file to have execute permission
6. Build project as module that can easily be distributed as tar/whl and installed using PIP
