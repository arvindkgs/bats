NOTES:
-----------------------------------------------------------------------------------------------------------------------------------------
1. If dependent py_modules cannot be installed, the go for the custom JSON parser, but remember to implement following feature for (OHS):
   '..' - go to any depth and fetch the item/s named the following word
   Example: IfModule..mpm_worker_module..ServerLimit
   So in 'IfModule' go to its children/grandchildren/great-grandchildren/etc, till 'mpm_worker_module' is found.
2. Using the 'jsonpath_rw_ext' parser, causes it to return only elements that are found, unlike custom JSON parser that adds 'None'
   if particular object in array does not have property.
   This should not affect unless a property can have multiple values.
3. The dynamic block produces a list of values.
           * Each value from this list is used to evaluate a source and corresponding property value.
           * These values are then compared.
           * So based on the ordering of the dynamic block values, source and target properties are computed and compared.
           * So LIMITATION is extrapolation resulting in size(n) source properties, should also result in similar extrapolation
             on the target as well.
4. Now dynamic map can store dict type object and used to extrapolate('property', 'file', 'hostname', 'username',
   'password' elements in metadata) by attributes of each object. Note that if the attribute is list type then it will
   iterate over each of the list objects and get the corresponding values, so effectively flattening the list.

To-Do
-----------------------------------------------------------------------------------------------------------------------------------------
1. Use REGEX for parsing format text.
2. Add STATIC type


Done
---------------------------------------------------------------------------------------------------------------------------------------
1. Use POJO for storing property instead of tuple to avoid array of values when using extend.
2. Add name to dynamic property instead of referring to it using index.
3. Add SHELL type.
4. Speed up dynamic matching by storing global dynamic map,
    4.1 Previously compare fetches same dynamic values from JSON for each check.
    4.2 Now dynamic map can store objects in map in global scope and reuse for each check.
       "tests": [{
           "dynamic": [
            {
              "key": "clusterObj",
              "file": "metadatas/tests/jvm/source.json",
              "type": "JSON",
              "property": "$..wlsClusters[*]"
            }
          ],
          "checks": [
            {
              "name": "Xms Check",
              "type": "COMPARE",
              "source": {
                "property": "$..wlsClusters[?(@.clusterName=${clusterObj.clusterName})].Xms",
                "file": "metadatas/tests/jvm/source.json",
                "type": "JSON"
              },
              "target": {
                "property": "fusion.FADomain.${clusterObj.clusterName}.default.minmaxmemory.main",
                "file": "metadatas/tests/jvm/target.properties",
                "type": "PROPERTY",
                "format": "-Xms{}?"
              }
            }
          ]
       }]
